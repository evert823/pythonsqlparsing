# 
# August 2021 Evert Jan Karman / evert823 / project to parse SQL using Python
# 
import os
import shutil
import sys
from datetime import datetime
from LowLevelLinesParser import LowLevelLinesParser
from sqlparser_commonclasses import SQLToken
from SQLPatternMatcher import SQLPatternMatcher
# from typing import ContextManager

#-----------------------------------------------------------------------------------------------
def parse_one_file():
    # Lines will be accessed in other functions
    # currentlinenumber and currentcolumnnumber will be accessed and changed in other functions
    global Lines
    global currentlinenumber
    global currentcolumnnumber
    global moved

    file1 = open(infile, 'r')
    Lines = file1.readlines()
    file1.close()

    MyLowLevelLinesParser = LowLevelLinesParser()
    MySQLPatternMatcher = SQLPatternMatcher()

    FoundTokens = MyLowLevelLinesParser.ParseLines(Lines, file_allrpt, infile)
    FoundTokensInPatterns = MySQLPatternMatcher.SQLPatternMatcher_main(FoundTokens, file_allrpt, infile)

    file2 = open(outfile, 'w')
    file2.write(myheader)

    for line in Lines:
        line1 = "    " + line
        file2.write(line1)
    file2.close()
#-----------------------------------------------------------------------------------------------
def prepare_folders(GetUserConfirmation):
    # Validation
    if infolder == outfolder:
        print("Outputfolder must be different from inputfolder")
        sys.exit()
    if os.path.isdir(infolder) == False:
        print("Inputfolder must exist")
        sys.exit()

    # Conditionally get user confirmation
    if GetUserConfirmation == True:
        val = input(outfolder + " will be removed, type yes if you're OK with that: ")
    else:
        val = "yes"

    # Remove specified outputfolder, get user confirmation
    if os.path.isdir(outfolder) == True:
        if val != "yes":
            print("Program will stop now")
            sys.exit()
        try:
            shutil.rmtree(outfolder)
        except OSError as e:
            print("Error: %s : %s" % (outfolder, e.strerror))

    # Recreate the specified outputfolder with entire subdirectory structure
    # from the specified inputfolder
    os.mkdir(outfolder)

    for root, subdirectories, files in os.walk(infolder):
        for subdirectory in subdirectories:
            dir_in = os.path.join(root, subdirectory)
            dir_out = dir_in.replace(infolder, outfolder)
            os.mkdir(dir_out)
#-----------------------------------------------------------------------------------------------
def process_folders():
    # Walk through the files from the input directory structure and for each file call the main function
    # for one single file
    global infile
    global outfile
    global allreportfile
    global file_allrpt

    allreportfile = outfolder + "/allreport_" + sys.argv[0] + ".report"
    file_allrpt = open(allreportfile, 'w')
    file_allrpt.write(infolder + ",0,0,0,0," + "MESSAGE,WARNING linenumbers and columnnumbers in this report are zero-based\n")

    for root, subdirectories, files in os.walk(infolder):
        for file in files:
            infile = os.path.join(root, file)
            outfile = infile.replace(infolder, outfolder)
            parse_one_file()
    file_allrpt.close()
#-----------------------------------------------------------------------------------------------

now = datetime.now()
dt_string = now.strftime("%d/%m/%Y %H:%M:%S")
myheader = "--Generated by " + sys.argv[0] + " " + dt_string + "\n"

if len(sys.argv) != 3:
    print(sys.argv[0] + " requires parameters for input foldername and output foldername relative to current dir")
    sys.exit()

infolder = './' + sys.argv[1]
outfolder = './' + sys.argv[2]

prepare_folders(False)
process_folders()
